package $packageName;

import java.io.IOException;
import java.net.URI;
import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import javax.websocket.CloseReason;
import javax.websocket.CloseReason.CloseCodes;
import javax.websocket.OnClose;
import javax.websocket.OnError;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;

import org.apache.commons.lang3.concurrent.BasicThreadFactory;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.commons.lang3.mutable.MutableBoolean;
import org.glassfish.tyrus.client.ClientManager;
import org.glassfish.tyrus.client.ClientProperties;
import org.glassfish.tyrus.client.SslEngineConfigurator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.thetransactioncompany.jsonrpc2.JSONRPC2Error;
import com.thetransactioncompany.jsonrpc2.JSONRPC2ParseException;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Request;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Response;

import io.reactivex.disposables.Disposable;
import io.reactivex.disposables.CompositeDisposable;
import io.reactivex.subjects.BehaviorSubject;
import io.reactivex.Single;
import net.minidev.json.JSONObject;
import net.psgglobal.wsrpc.core.WsRpcCompositFuture;

/**
 * Generated with Velocity - DO NOT EDIT
 *
 * This class is the client side Actor
 *
 * This class supports text communications via the WebSocket
 */
public abstract class ${specname}Actor implements AutoCloseable {
	protected Logger logger = LoggerFactory.getLogger(getClass().getName());
	private static AtomicInteger ActorCount = new AtomicInteger();
	private static AtomicLong LastRequestId = new AtomicLong();

	private int actorId = ActorCount.incrementAndGet();
	private ClientManager client;
	private URI wsrpcServerUri;
	private ClientManager.ReconnectHandler reconnectHandler;
	private final WsRpcCompositFuture compositFutures = new WsRpcCompositFuture();
#if ($synchronized == "client" || $synchronized == "both")
	private ExecutorService threadPool = Executors.newSingleThreadExecutor(new BasicThreadFactory.Builder().daemon(true).namingPattern("wsrpc-${specname}-%d").build());
#else
	private static ExecutorService threadPool = Executors.newCachedThreadPool(new BasicThreadFactory.Builder().daemon(true).namingPattern("wsrpc-${specname}-%d").build());
#end
	private static ScheduledExecutorService schedulePool = Executors.newScheduledThreadPool(1, new BasicThreadFactory.Builder().daemon(true).namingPattern("wsrpc-${specname}-sched-%d").build());
	private final CompositeDisposable compositeDisposable = new CompositeDisposable();
	private final Semaphore authenticationSemophore = new Semaphore(0);

	protected final Map<Long, BehaviorSubject<JSONRPC2Response>> responseSubjects = new HashMap<>();
	protected SslEngineConfigurator sslEngineConfigurator;
	protected Session wsSession;
	protected Future<Session> connectFuture;
	protected final MutableBoolean authenticated = new MutableBoolean(false);
	protected final BlockingQueue<ByteBuffer> binaryDataQueue = new LinkedBlockingQueue<>();
	
	/**
	 * Override this function allowing WSRPC to get the correct JWT.
	 * @return the authorized JWT
	 */
	abstract public String getJWTAuthenticationToken();

	/**
	 * Constructor
	 */
	public ${specname}Actor() {
	}

	/**
	 * Constructor
	 * @param serverUrl the server URL
	 */
	public ${specname}Actor(String serverUrl) {
		Runtime.getRuntime().addShutdownHook(new Thread() {
			public void run() {
				if (client != null) client.shutdown();
			}
		});
		wsrpcServerUri = URI.create(serverUrl);
	}

	/**
	 * Constructor
	 * @param serverUrl the server URL
	 * @param reconnectHandler the reconnection handler to use
	 */
	public ${specname}Actor(String serverUrl, ClientManager.ReconnectHandler reconnectHandler) {
		Runtime.getRuntime().addShutdownHook(new Thread() {
			public void run() {
				if (client != null) client.shutdown();
			}
		});
		this.reconnectHandler = reconnectHandler;
		wsrpcServerUri = URI.create(serverUrl);
	}
	
	/**
	 * If the user failed to close the websocket, close it before it is garbage collected
	 */
	@Override
	protected void finalize() throws Throwable {
		if (wsSession != null && wsSession.isOpen()) {
			logger.error("Actor {} connected to {} is being garbage collected but was not closed. Closing...", actorId, wsrpcServerUri);
			try {
				wsSession.close(new CloseReason(CloseReason.CloseCodes.NORMAL_CLOSURE, "finalizer"));
				if (client != null) client.shutdown();
			} catch (IOException e) {
				logger.warn("Actor {} {} Error closing connection: {}", actorId, wsrpcServerUri, ExceptionUtils.getMessage(e));
			}
		}
	}

	/**
	 * @return the server connection URL
	 */
	public URI getWsrpcServerUri() {
		return wsrpcServerUri;
	}

	/**
	 * @return the actor id
	 */
	public int getActorId() {
		return actorId;
	}

	/**
	 * Connect to the server
	 * @param connectTimeout the timeout to wait for connection
	 * @return true if connection and authentication were successful
	 */
	public synchronized boolean connect(int connectTimeout) {
		return connect(null, connectTimeout);
	}
	
	/**
	 * Connect to the server
	 * @param clientProperties extra client properties to set on connect
	 * @param connectTimeout the timeout to wait for connection
	 * @return true if connection and authentication were successful
	 */
	public synchronized boolean connect(Map<String, Object> clientProperties, int connectTimeout) {
		if (client != null) return true;
		authenticated.setValue(false);
		authenticationSemophore.drainPermits();
		
		try {
			if (logger.isDebugEnabled()) logger.debug("Actor {} connecting to {}", actorId, wsrpcServerUri);
			client = ClientManager.createClient();
			client.getProperties().put(ClientProperties.SHARED_CONTAINER, true);
			client.getProperties().put(ClientProperties.SHARED_CONTAINER_IDLE_TIMEOUT, 5);
			if (clientProperties != null) client.getProperties().putAll(clientProperties);
			if (sslEngineConfigurator != null) client.getProperties().put(ClientProperties.SSL_ENGINE_CONFIGURATOR, sslEngineConfigurator);

			if (this.reconnectHandler != null) 
				client.getProperties().put(ClientProperties.RECONNECT_HANDLER, reconnectHandler);
			else 
				client.getProperties().put(ClientProperties.RECONNECT_HANDLER, new ClientManager.ReconnectHandler() {

					private int counter;

					@Override
					public boolean onDisconnect(CloseReason closeReason) {
						if (closeReason.getCloseCode().equals(CloseReason.CloseCodes.NORMAL_CLOSURE)) return false;
						authenticated.setValue(false);
						authenticationSemophore.release();
						counter++;
						if (logger.isDebugEnabled()) logger.debug("Actor {} reconnecting to {} attempt {} because closed: {} {}", actorId, wsrpcServerUri, counter, closeReason.getCloseCode(), closeReason.getReasonPhrase());
						return true;
					}

					@Override
					public boolean onConnectFailure(Exception exception) {
						counter++;
						if (logger.isDebugEnabled()) logger.debug("Actor {} reconnecting to {} attempt {} because connect failed: {}: {}", actorId, wsrpcServerUri, counter, ExceptionUtils.getMessage(exception), ExceptionUtils.getRootCauseMessage(exception));
						return true;
					}
					
					@Override
					public long getDelay() {
						return 2;
					}
				});

			connectFuture = client.asyncConnectToServer(this, wsrpcServerUri);

			// wait for authentication
			if (!authenticationSemophore.tryAcquire(connectTimeout, TimeUnit.MILLISECONDS)) logger.warn("Actor {} {} Timed out waiting for authentication", actorId, wsrpcServerUri);
			return authenticated.booleanValue();
		} catch (Throwable e) {
			logger.warn("Actor {} {} Error connecting to server: {}", actorId, wsrpcServerUri, ExceptionUtils.getMessage(e), e);
			return false;
		}
	}

	/**
	 * Close the connection
	 */
	public void close() {
		close(new CloseReason(CloseReason.CloseCodes.NORMAL_CLOSURE, "Operator request"));
	}

	/**
	 * Close the connection
	 * @param closeReason the reason for the close
	 */
	public void close(CloseReason closeReason) {
		// close the session
		try {
			compositeDisposable.dispose();
			if (connectFuture != null && !connectFuture.isDone() && !connectFuture.isCancelled()) connectFuture.cancel(true);
			if (wsSession != null) wsSession.close(closeReason);
		} catch (IOException e) {
			logger.warn("Actor {} {} Error closing connection: {}", actorId, wsrpcServerUri, ExceptionUtils.getMessage(e));
		}
		wsSession = null;
		
		// on normal close, shutdown client
		if (closeReason.getCloseCode().equals(CloseReason.CloseCodes.NORMAL_CLOSURE)) {
			if (client != null) client.shutdown();
			client = null;
		}
	}
	
	/**
	 * @return true if connected and authenticated
	 */
	public boolean isReady() {
		return wsSession != null && authenticated.booleanValue();
	}

	/**
	 * The session has been opened
	 * @param wsSession the session
	 */
	@OnOpen
	public void onOpen(Session wsSession) {
		if (logger.isDebugEnabled()) logger.debug("Actor {} opened to {} with session id {}", actorId, wsrpcServerUri, wsSession.getId());
		this.wsSession = wsSession;
#if ($maxTextMessageSize != "0")
		this.wsSession.setMaxTextMessageBufferSize($maxTextMessageSize);
#end
		String userJwtToken = getJWTAuthenticationToken();

		try {
			if (userJwtToken == null) {
				logger.info("Actor {} No JWT authentication code available", actorId);
				schedulePool.schedule(() -> close(new CloseReason(CloseCodes.UNEXPECTED_CONDITION, "Not Authenticated")), 500, TimeUnit.MILLISECONDS);
				return;
			}
			Map<String, Object> params = new HashMap<>();
			params.put("token", userJwtToken);
			JSONRPC2Request request = new JSONRPC2Request("Authenticate", params, LastRequestId.incrementAndGet());
			if (logger.isDebugEnabled()) logger.debug("Send authentication: {}", request.toJSONString());
			BehaviorSubject<JSONRPC2Response> responseSubject = BehaviorSubject.create();
			responseSubjects.put((Long)request.getID(), responseSubject);
			if (logger.isDebugEnabled()) logger.debug("Send request: {}", request.toJSONString());
			wsSession.getBasicRemote().sendText(request.toJSONString());
			addDisposable(responseSubject.singleOrError().timeout(10, TimeUnit.SECONDS).subscribe(
					authResponse -> {
						if (logger.isDebugEnabled()) logger.debug("Authentication response: {}", authResponse.toJSONString());
						authenticated.setValue(!authResponse.indicatesSuccess() ? false : (boolean)authResponse.getResult());
						if (!authenticated.getValue()) logger.warn("Authentication failed: {}", authResponse.toJSONString());
						authenticationSemophore.release();
					},
					authError -> {
						logger.warn("Actor {} {} Error authenticating with JWT {}: {}", actorId, wsrpcServerUri, userJwtToken, ExceptionUtils.getMessage(authError));
						authenticated.setValue(false);
						authenticationSemophore.release();
						schedulePool.schedule(() -> close(new CloseReason(CloseCodes.UNEXPECTED_CONDITION, "Authentication Error")), 500, TimeUnit.MILLISECONDS);
					}
					));
		} catch (IOException e) {
			logger.warn("Actor {} {} Error sending authenticate request: {}", actorId, wsrpcServerUri, ExceptionUtils.getMessage(e));
			authenticated.setValue(false);
			authenticationSemophore.release();
			close(new CloseReason(CloseCodes.UNEXPECTED_CONDITION, "Authentication Error"));
		}
	}

	/**
	 * The session has been closed
	 * @param closeReason the reason it was closed
	 * @param wsSession the session
	 */
	@OnClose
	public void onClose(CloseReason closeReason, Session wsSession) {
		logger.info("Actor {} closed connection to {} due to {} {}", actorId, wsrpcServerUri, closeReason.getCloseCode(), closeReason.getReasonPhrase());
		compositFutures.cancelRemaining(true);
		if (closeReason.getCloseCode().equals(CloseReason.CloseCodes.NORMAL_CLOSURE)) {
#if ($synchronized == "server" || $synchronized == "both")
			threadPool.shutdown();
#end
		}
		this.wsSession = null;
		authenticated.setValue(false);
		authenticationSemophore.release();
	}

	/**
	 * Called when an error is found on a locker
	 * @param wsSession the websocket session
	 * @param error the error
	 */
	@OnError
	public void onError(Session wsSession, Throwable error) {
		logger.warn("Actor {} {} WebSocket error: {}", actorId, wsrpcServerUri, ExceptionUtils.getMessage(error), error);
	}
	
	/**
	 * Override this method to process the authenticated event
	 * @param success true if the authentication was successful
	 */
	public void onAuthenticated(boolean success) {
	}

	/**
	 * Send an error response
	 * @param requestId the request id
	 * @param error the error
	 */
	public void sendResponse(JSONRPC2Error error, Long requestId) throws IOException {
		if (logger.isDebugEnabled()) logger.debug("Send error response: {} for request {}", error, requestId); 
		wsSession.getBasicRemote().sendText(new JSONRPC2Response(error, requestId).toJSONString());
	}

	/**
	 * Send a response
	 * @param response the response
	 */
	public void sendResponse(JSONRPC2Response response) throws IOException {
		if (logger.isDebugEnabled()) logger.debug("Send response: {}", response.toJSONString());
		wsSession.getBasicRemote().sendText(response.toJSONString());
	}

	/**
	 * Send a response
	 * @param requestId the original request id
	 */
	public void sendSilentResponse(long requestId) {
		try {
			String jsonResponse = new JSONRPC2Response(requestId).toJSONString();
			if (logger.isDebugEnabled()) logger.debug("Send response: {}", jsonResponse);
			wsSession.getBasicRemote().sendText(jsonResponse);
		} catch (Exception e) {
			logger.warn("Actor {} {} Error sending response: {}", actorId, wsrpcServerUri, ExceptionUtils.getMessage(e));
		}
	}

	/**
	 * Send a response
	 * @param result the method's result object
	 * @param requestId the original request id
	 */
	public void sendSilentResponse(Object result, long requestId) {
		try {
			String jsonResponse = new JSONRPC2Response(result, requestId).toJSONString();
			if (logger.isDebugEnabled()) logger.debug("Send response: {}", jsonResponse);
			wsSession.getBasicRemote().sendText(jsonResponse);
		} catch (Exception e) {
			logger.warn("Actor {} {} Error sending response: {}", actorId, wsrpcServerUri, ExceptionUtils.getMessage(e));
		}
	}

#foreach ($request in $serverRequests)
	/**
	 * process a  $request.name request
	 * @param request the request
	 */
	public abstract void on${display.capitalize($request.name)}(${request.name}Request request);
	
#end
#foreach ($notice in $serverNotices)
	/**
	 * process a  $notice.name notice
	 * @param notice the notice
	 */
	public abstract void on${display.capitalize($notice.name)}(${notice.name}Notice notice);
	
#end
	/**
	 * Process an inbound message
	 * @param json the JSON message
	 * @param wsSession the WebSocket session
	 */
	@OnMessage
	public void onMessage(String json, Session wsSession) {

		// JSON message
		if (logger.isDebugEnabled()) logger.debug("Actor {} OnMessage: {}", actorId, json);

		// process results
		try {
			JSONRPC2Response response = JSONRPC2Response.parse(json);
			if (!responseSubjects.containsKey(response.getID())) {
				logger.warn("No one waiting for response {}: {}", response.getID(), response.toJSONString());
			} else {
				BehaviorSubject<JSONRPC2Response> responseSubject = responseSubjects.remove(response.getID());
				responseSubject.onNext(response);
				responseSubject.onComplete();
			}
			return;
		} catch (JSONRPC2ParseException e) {
			if (logger.isDebugEnabled()) logger.debug("Actor {} Error processing response message {}: {}", actorId, json, ExceptionUtils.getMessage(e));
		} catch (Throwable e) {
			logger.warn("Actor {} {} Error processing response message {}: {}", actorId, wsrpcServerUri, json, ExceptionUtils.getMessage(e));
		}

		// process the message
		try {
			JSONRPC2Request request = JSONRPC2Request.parse(json);

			// process methods
#foreach ($request in $serverRequests)
			if (${display.capitalize($request.name)}Request.canNarrow(request)) compositFutures.add(threadPool.submit(() -> on${display.capitalize($request.name)}(${display.capitalize($request.name)}Request.narrow(request))));
#end
#foreach ($notice in $serverNotices)
			if (${display.capitalize($notice.name)}Notice.canNarrow(request)) compositFutures.add(threadPool.submit(() -> on${display.capitalize($notice.name)}(${display.capitalize($notice.name)}Notice.narrow(request))));
#end

			return;
		} catch (JSONRPC2ParseException e) {
			if (logger.isDebugEnabled()) logger.debug("Actor {} Error processing message {}: {}", actorId, json, ExceptionUtils.getMessage(e));
		} catch (Throwable e) {
			logger.warn("Actor {} {} Error processing message {}: {}", actorId, wsrpcServerUri, json, ExceptionUtils.getMessage(e), e);
		}
	}

#foreach ($request in $clientRequests)
	/**
	 * Asynchronous $request.name request
#foreach ($parameter in $parameters)
#if ($parameter.javadoc)
	 * @param $parameter.name $parameter.javadoc
#end
#end
	 * @param timeout the call timeout in milliseconds
	 */
	public Single<JSONRPC2Response> async${display.capitalize($request.name)}(#foreach ($parameter in $request.parameters)$parameter.type $parameter.name, #end  int timeout) throws IOException {
		if (!authenticated.booleanValue()) {
			if (logger.isDebugEnabled()) logger.debug("Actor {} WebSocket not connected", actorId);
			return  Single.just(new JSONRPC2Response(JSONRPC2Error.INTERNAL_ERROR.appendMessage(" Not connected"), 0));
		}
		${display.capitalize($request.name)}Request request = new ${display.capitalize($request.name)}Request(#foreach ($parameter in $request.parameters)$parameter.name, #end LastRequestId.incrementAndGet());
		BehaviorSubject<JSONRPC2Response> responseSubject = BehaviorSubject.create();
		responseSubjects.put(request.getRequestId(), responseSubject);
		if (logger.isDebugEnabled()) logger.debug("Send request: {}", request.toJSONString());
		wsSession.getBasicRemote().sendText(request.toJSONString());
		return responseSubject.singleOrError().timeout(timeout, TimeUnit.MILLISECONDS);
	}
	
#end

#foreach ($request in $clientRequests)
	/**
	 * Synchronous $request.name request
#foreach ($parameter in $parameters)
#if ($parameter.javadoc)
	 * @param $parameter.name $parameter.javadoc
#end
#end
	 * @param timeout the call timeout in milliseconds
	 */
	public $request.returns ${display.uncapitalize($request.name)}(#foreach ($parameter in $request.parameters)$parameter.type $parameter.name, #end int timeout) throws IOException {
		JSONRPC2Response response = async${display.capitalize($request.name)}(#foreach ($parameter in $request.parameters)$parameter.name, #end timeout)
				.onErrorReturn((e) -> { 
					if (logger.isDebugEnabled()) logger.debug("${display.uncapitalize($request.name)}: {}", ExceptionUtils.getMessage(e)); 
					return new JSONRPC2Response(JSONRPC2Error.INTERNAL_ERROR.appendMessage(" " + ExceptionUtils.getMessage(e)), 0); 
				})
				.blockingGet();
		if (response == null) throw new IOException("TimeOut");
		if (response.getError() != null) {
			if (logger.isDebugEnabled()) logger.debug("${display.uncapitalize($request.name)}: returned error {}", response.getError().getMessage()); 
			throw new IOException(response.getError().getMessage());
		}
#if ($request.returns == "void")
#elseif ($request.returns.indexOf(".") > 0)
		return ${request.returns}.parse((JSONObject)response.getResult());
#elseif ($request.returns == "int")
		return ((Long) response.getResult()).intValue();
#else
		return ($request.returns) response.getResult();
#end
	}
	
#end

#foreach ($request in $clientRequests)
	/**
	 * Synchronous $request.name request
	 * This request uses the default timeout value
#foreach ($parameter in $parameters)
#if ($parameter.javadoc)
	 * @param $parameter.name $parameter.javadoc
#end
#end
	 */
	public $request.returns ${display.uncapitalize($request.name)}(#foreach ($parameter in $request.parameters)$parameter.type $parameter.name#if($foreach.hasNext), #end#end) throws IOException {
#if ($request.returns != "void")
		return ${display.uncapitalize($request.name)}(#foreach ($parameter in $request.parameters)$parameter.name, #end $request.defTimeout);
#else
		${display.uncapitalize($request.name)}(#foreach ($parameter in $request.parameters)$parameter.name, #end $request.defTimeout);
#end
	}

#end

#foreach ($request in $clientRequests)
	/**
	 * Asynchronous $request.name request
	 * This request uses the default timeout value
#foreach ($parameter in $parameters)
#if ($parameter.javadoc)
	 * @param $parameter.name $parameter.javadoc
#end
#end
	 */
	public Single<JSONRPC2Response> async${display.capitalize($request.name)}(#foreach ($parameter in $request.parameters)$parameter.type $parameter.name#if($foreach.hasNext),#end#end) throws IOException {
		return async${display.capitalize($request.name)}(#foreach ($parameter in $request.parameters)$parameter.name, #end $request.defTimeout);
	}
	
#end

	/**
	 * @return the next request id
	 */
	protected static long nextRequestId() {
		return LastRequestId.incrementAndGet();
	}
	
	/**
	 * add a disposable to the composit disposable object.
	 * These will be disposed when the client is closed.
	 * @param disposable the CompositeDisposable
	 */
	public void addDisposable(Disposable disposable) {
		compositeDisposable.add(disposable);
	}

	/**
	 * Check if actor is connected
	 * @return true if connected
	 */
	public boolean isConnected() {
		return wsSession != null && wsSession.isOpen();
	}

	/**
	 * Test if actor is authenticated
	 * @return true if authenticated
	 */
	public boolean isAuthenticated() {
		return authenticated.booleanValue();
	}
	
	/**
	 * Wait for all futures to complete
	 * @param timeout the timeout
	 * @param timeUnit the timeout units
	 * @throws ExecutionException error
	 * @throws TimeoutException error
	 */
	public void waitForAll(int timeout, TimeUnit timeUnit) throws ExecutionException, TimeoutException {
		try { compositFutures.waitForAll(timeout, timeUnit); } catch (InterruptedException e) { logger.debug("Wokeup"); }
	}

}
